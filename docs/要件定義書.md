# AI Pick Daily - 要件定義書 (v2.2 / 統合最終版)

**作成日**: 2025年12月21日
**最終更新**: 2025年12月21日 (最終監査フィードバック反映 + 申し送り統合 + Appendix C統合 + 厳密チェック修正反映)
**プロジェクト名**: AI Pick Daily（AIが毎日銘柄を推奨するサービス）
**バージョン**: 2.2

---

## 実装チームへの申し送り（CRITICAL）

### A. GitHub Actions（課金・暴走防止）

- **全Workflow Jobに `timeout-minutes: 20` を必須設定**（無設定時の長時間実行・無料枠消費リスクを回避）。

```yaml
jobs:
  batch:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - run: python main.py
```

### B. Geminiモデル運用（必須）

- **日次スコアリング（朝バッチ）**: `gemini-3-flash`
- **反省文生成/深掘り分析（夕方バッチ）**: `gemini-3-pro`
- 実装時は、モデル名をハードコードせず **環境変数 or 設定ファイル**で切替できる構造にすること（将来のモデル更新に備える）。

### C. Critical 3項目（絶対バグ禁止）

1. **決算フィルター**: 今後3営業日以内のEarnings Call銘柄は強制除外
2. **価格基準**: パフォーマンス計測のEntry Priceは「当日Open価格」に統一
3. **API実装要件**: Gemini/Finnhub呼び出しに対する`sleep`とリトライ処理を必須化（429対策）

---

## 主な修正点（v2.0 → v2.1）

### 最終監査で追加（Critical Implementation Items）

- ✅ **決算フィルター追加**: 今後3営業日以内のEarnings Call銘柄は強制除外
- ✅ **価格基準の明確化**: パフォーマンス計測のEntry Priceは「当日Open価格」に統一
- ✅ **API実装要件**: Gemini/Finnhub呼び出しに対する`sleep`とリトライ処理を明記
- ✅ **ニュース永続化**: URLだけでなく記事タイトル・発信元をテキスト保存

---

## 1. プロジェクト概要

### 1.1 目的

膨大な株式市場データから、複数の指標とAI分析を組み合わせて、**相場環境に応じた**「買い推奨銘柄」を自動生成し、ユーザーに配信するWebアプリケーション。自動振り返り機能により、推奨精度を継続的に改善する学習ループを実現する。

> **重要な限界の明示**: 市場は本質的にランダムな側面がある。AIの推奨精度は相場環境（トレンド/レンジ/危機）によって大きく変動し、60-65%程度が現実的な上限である。

### 1.2 コンセプト

- 「どの銘柄を見ればいいかわからない」というユーザー課題を解決
- AIが市場を24時間監視し、毎朝「今日の注目株」を提案
- **相場が悪い日は「推奨なし」と判定する勇気**を持つ
- ユーザーは見るだけ→判断は自分で行う（推奨型、非自動発注）
- 時間が経つほど精度が向上する「自己学習AI」（ただし成長は緩やか）

### 1.3 想定ユーザー

- 株初心者〜中級者で、銘柄選定に困っている個人投資家
- 日中忙しくて市場リサーチできないビジネスパーソン
- AIの判断プロセスを学びたいトレーダー

---

## 2. 技術スタック

| 層 | 技術 | 選定理由 |
| :--- | :--- | :--- |
| **Frontend** | Next.js 15 (React) | 高速、SEO対応、Vercelホスティング対応 |
| **Backend / DB** | Supabase (Postgres + Auth) | 認証・DB・Real-time通知を一元化、無料枠が充実 |
| **AI / LLM** | Google Gemini API（`gemini-3-flash` / `gemini-3-pro`） | 多言語、長文入力対応、無料枠あり、柔軟なプロンプト設計（運用：日次=Flash、反省文=Pro） |
| **マーケットデータ** | Finnhub API（無料） | リアルタイム株価、ニュースセンチメント、財務情報、Earnings Calendar |
| **スケジューリング** | GitHub Actions Workflow（**推奨**）または Google Cloud Run Jobs | Edge Functions は10-60秒の時間制限のため、本バッチ処理には不適切。GitHub Actions は最大6時間稼働可能。レート制限回避の`sleep`処理を実装。 |
| **ホスティング** | Vercel + Supabase | CI/CD自動化、スケーラビリティ |
| **チャート表示** | TradingView Lightweight Charts | 軽量、無料、レスポンシブ |
| **通知** | Supabase メール送信 + OneSignal (Phase 3) | プッシュ通知対応 |

---

## 3. 機能要件

### 3.1 メイン機能

#### 3.1.1 AIスクリーニング・スコアリング

**概要**: 複数の指標を組み合わせて、毎日の推奨銘柄を自動決定する。**ただし相場環境判定をTier 1として最優先する。**

#### 3.1.1.1 Tier 1: Market Regime フィルター（足切り機能）

このステップで「推奨を出すべき相場か」を判定。結果によってその後の処理を大きく分岐させる。

**判定基準**（複合条件）：

| 指標 | 条件 | アクション |
| :--- | :--- | :--- |
| **VIX** | > 30（恐怖指数） | ⚠️ 「危機モード」→ 推奨スコアを全て -30点 OR 推奨を控える |
| **S&P 500の乖離** | SMA20 から下 -3% 以上 | ⚠️ 「調整局面」→ Value Agent の優先度を強制的に +10% に昇格 |
| **ボラティリティクラスター** | 過去5日の平均変動率が通常の2倍 | ⚠️ 「不安定」→ Momentum Agent の信頼度を -20%（ノイズが多いため） |
| **マーケット広幅（Phase 2で有効化）** | （データソース確定後に導入） | Phase 1では使用しない（実装停止を防ぐため） |

**判定結果**:

- ✅ **正常相場**: 通常ロジックで進める → Tier 2へ
- ⚠️ **調整相場**: 各エージェント重みを自動調整して進める → Tier 2へ（ただし推奨数上限を3に引き下げ）
- 🛑 **危機相場**: 推奨銘柄数を2に制限、または「推奨なし」と判定 → 推奨数ゼロもあり

このTier 1フィルターは、過去のノイズに過学習して損するAIの歴史的な失敗を防ぐために必須。

#### 3.1.1.2 Tier 2: マルチエージェント評価

Market Regime判定をパスした場合、以下の指標を組み合わせてスコアリング。

**指標構成（初期版）**:

| Agent / 指標カテゴリ | 主要評価軸 | 重み（初期値） | 重み範囲 | 説明 |
| :--- | :--- | :--- | :--- | :--- |
| **Trend Agent** | SMA(20/50/200), MACD, 高値新値度 | 35% | 20-45% | 中期トレンドの方向性と勢い。短期トレーディングでは最重要。 |
| **Momentum Agent** | RSI(14), 出来高急増(5日平均比), 52週高値接近度 | 35% | 20-45% | 短期の勢い・エネルギー。価格は感情で動くため重要。 |
| **Value Agent** | PER（業界平均比）, PBR, 配当利回り | 20% | 10-30% | 割安性。短期には効かないが、数週間以上で機能。 |
| **Sentiment Agent** | ニュース数（過去7日）, ニュース・センチメントスコア（Finnhub）, インサイダー買い有無 | 10% | 5-20% | 市場心理・話題性。最もノイズが多いため、低ウエイト。 |

**重み調整ルール**（Market Regime に基づく）:

- 🔴 危機相場 → Trend -10%, Momentum -10%, Value +15%, Sentiment 変わらず
- 🟡 調整相場 → Trend +5%, Momentum +5%, Value 変わらず, Sentiment -10%
- 🟢 正常相場 → 初期値のまま

**総合スコア**: 上記4つを統合して 0-100 の数値を算出。

**スコア解釈**:

- 75-100: Strong Buy（推奨対象の最上位）
- 60-74: Moderate Buy（推奨対象）
- 45-59: Hold / Watch（推奨外だが監視対象）
- < 45: Pass（対象外）

#### 3.1.1.3 Tier 3: 相対化（ランク付け）

その日の候補銘柄全体に対して、スコアを**偏差値化**し、ランキングする。

**なぜ相対化が必要か**:

- 相場全体が良い日：全員90点になる（選別不可）
- 相場全体が悪い日：全員30点になる（選別不可）
- **相対化により、「その日の中での優勝者」を見つける** → より実用的

**実装**:

```python
Z_score = (composite_score - mean) / std_dev
percentile = PERCENTILE_RANK(Z_score, all_scores)
```

**フェイルセーフ（必須）**:
std_dev が 0 または極小（例: std_dev < 1e-6）の場合、Z-score を計算せず、composite_score の順位から percentile_rank を算出する（同点は平均順位）。これにより「全員同点」や「候補数が少ない日」でも必ずランキングが生成できる。

#### 3.1.1.4 推奨銘柄数の決定

**アルゴリズム**:

```python
IF market_regime == "crisis":
    max_picks = 0  # 推奨なし
ELIF market_regime == "adjustment":
    max_picks = 3
ELSE:
    max_picks = 5  # 正常相場

# フェイルセーフ（必須）: 候補数で上限をクリップ
max_picks = MIN(max_picks, COUNT(candidates))

IF max_picks == 0:
    final_picks = []
ELSE:
    # スコア順でランキング、top_N を取得
    final_picks = TOP_N_BY_PERCENTILE(candidates, max_picks)
```

**重要**: 「毎日N個出す」のではなく、**「その日の相場が良い日だけ出す」勇気を持つ**。

#### 3.1.1.5 データ取得フロー（決算フィルター含む）

1. **前日夜** (18:00-20:00 JST / 03:00-05:00 ET):
   - Finnhub API で全NYSE/NASDAQ銘柄の価格、財務、ニュース取得
   - **Finnhub Earnings Calendar API で、今後3営業日以内の決算予定銘柄を抽出（重要）**
   - テクニカル指標を計算（SMA, RSI, MACD）
   - Supabase に保存

2. **朝マーケット直前** (07:00 JST / 16:00 ET 前日):
   - Market Regime 判定（VIX, 相場広幅 など）
   - **決算フィルター適用（Critical）**: 今後3営業日以内にEarnings Callがある銘柄は、どんなスコアが高くても強制除外。テクニカル分析は決算前後で無効化されるため。
   - 流動性フィルター適用（時価総額 > ¥300B 相当、出来高 > 100万株）
   - ニュース数・センチメント基準で粗選別 → 候補を 50-100 銘柄に絞る
   - GitHub Actions が起動し、絞り込み銘柄の詳細データを Gemini に投げ、スコア計算（モデル: **gemini-3-flash**）
     - **レート制限対策**: Gemini API呼び出し間に `time.sleep(1-2秒)` を挿入、または exponential backoff リトライを実装
   - スコア結果を Supabase に保存
   - 相対化してランキング、上位銘柄を `daily_picks` に INSERT
   - 通知トリガー（メール、プッシュ）

> **Note**: この処理は平均 5-10分で完了予定。Edge Functions の時間制限（10-60秒）では困難なため、GitHub Actions（Cron Workflow）で実行。

**"3営業日"の定義（必須）**: NYSE取引日カレンダー上の次の3セッション（3 trading days）を指す。土日・祝日・臨時休場・短縮取引日はカレンダーに従う。

**監査証跡（必須）**: 推奨生成バッチは `cutoff_timestamp`（UTC）を必ず1つ決定し、以降の全データ取得・Gemini入力は cutoff 以前のデータのみに限定する。バッチ完了時に `stock_scores.cutoff_timestamp` と `stock_scores.input_data_asof` を必ず保存し、後日再現可能な状態にする。

**タイムゾーン統一（必須）**: Earnings情報は `earnings_timezone` を必ず保存し、内部判定はUTC（`earnings_timestamp_utc`）へ変換した値を用いる。市場タイムゾーンは Finnhub の Market Status / Market Holiday の `timezone` を正とする。

`earnings_timestamp_utc` が不明（null）の場合は `earnings_date` と `earnings_time_of_day` に基づき "その取引日〜次の3セッション" を保守的に決算ウィンドウとみなし除外する（取りこぼしより誤推薦防止を優先）。

実装例: Pythonでは `pandas_market_calendars` のNYEカレンダー（`mcal.get_calendar('NYSE')` と `schedule()`）で取引日レンジを生成し、Earnings日時がそのレンジに入る銘柄を除外する。

---

#### 3.1.2 ダッシュボード表示

**UI構成**:

- **トップページ（Today's Picks）**:
  - カード形式で今日の推奨銘柄を表示（0-5件）
  - **推奨なしの日の表示**: 「今日は相場が不安定なため、推奨銘柄を控えています」とメッセージ表示
  - 各カード内容:
    - 銘柄コード（例: TSLA）
    - 現在価格 + 前日比（%）
    - **⚠️ 注記**: 「※表示価格は前日終値です。寄付価格は大きく変動する可能性があります」
    - 総合スコア（偏差値ベース、相対ランク「1位」など表示）
    - 推奨理由（1-2行、Gemini生成）
    - **引用元の明示**: 「ニュース出典: Finnhub (ID: xxx)」など
    - **決算警告**: 該当銘柄の場合「⚠️ 決算発表予定: 2025-12-24」を表示
  - スワイプまたはスクロール可能（モバイル対応）

- **銘柄詳細ビュー** (クリック後):
  - TradingView Lightweight Chart（5日足など）
  - **スコア内訳**（下記参照、重要）:
    - 📈 トレンド: XX/100 (当日の重み: 35%)
    - ⚡ モメンタム: XX/100 (当日の重み: 35%)
    - 💰 割安度: XX/100 (当日の重み: 20%)
    - 📰 センチメント: XX/100 (当日の重み: 10%)
    - **総合スコア（相対値）**: 今日の候補の中で 第X位
  - **Market Regime 表示**: 「今日の相場環境: 正常（VIX: 16）」
  - Geminiが書いた詳細推奨理由
    - ただし、**ハルシネーション対策**: データ部分は必ず引用元（API、日時）を記載
    - 例：「2025-12-21 03:00 UTCのFinnhub データより、RSI=72 で売られすぎ傾向。過去30日の平均RSIは62のため、リバウンド期待。」
  - 過去リターン（推奨結果の追跡）:
    - 「前回この銘柄を推奨したのは X日前、当時 $ YYY → 現在 $ ZZZ」
  - **決算警告**: 「⚠️ 今後3営業日以内に決算発表があります。ボラティリティが拡大する可能性があります。」
  - 「見送り」「興味あり」ボタン（フィードバック用）

- **パフォーマンスダッシュボード** (タブ2):
  - **📊 超過リターン（Alpha）ダッシュボード**:
    - 過去 30日の **「推奨銘柄群 vs S&P 500」** の累積リターン曲線
    - 「AIピック +12.3% vs ベンチ +8.1%」 = Alpha +4.2%
    - シャープレシオ（もしくは最大ドローダウン）
  - **📈 Best Pick / Worst Pick ランキング**:
    - 当てた銘柄トップ5とその成績（当日から5日後のリターン）
    - 外した銘柄ワースト3とその成績
  - **📚 Today's Lesson**:
    - AIが「今日の失敗から何を学んだか」をテキスト化（Gemini生成：モデルは原則 **gemini-3-pro**）
    - 例：「昨日推奨の NVDA が期待に反して暴落。理由は市場全体のテック売り圧力。明日は Sentiment の信頼度を下げて対応します。」
    - ただし、理由の根拠は引用元付きで。
  - **📊 エージェント別勝率推移**（グラフ）:
    - 過去30日間の、各エージェント（Trend, Momentum, Value, Sentiment）の勝率推移
    - 「Trend Agent は68%、Sentiment Agent は45%」など
  - **⚙️ 現在の重み表示**:
    - 最新の indicators_weights を表示（読み取り専用）
    - 「前日比: Trend +1%↑, Sentiment -1%↓」

---

#### 3.1.3 自動振り返り・重み調整（学習ループ）

**極めて重要**: 「単純な勝敗ベース調整」は禁止。代わりに、**「相場環境別の戦績」を分析する**。

**実行タイミング**: 毎日マーケットクローズ後（16:00 ET / 翌朝6:00 JST）

**処理フロー**:

1. **勝敗判定（複数期間）**:
   - **判定価格の基準（Critical）**: パフォーマンス計測のEntry Priceは、**推奨日の当日Open価格**を採用する。
     - 理由：好材料でGap Up（窓開け上昇）した場合、前日終値から乖離するため。
   - **5日後**: 推奨時から5営業日後のClose価格で判定（短期トレード対象）
   - **当日内**: 推奨時（Open）から同日クローズまでのリターン（スキャルピング対象）
   - **判定基準**: ±1% 以上の動きを「判定対象」とし、-1% 〜 +1% は「フラット」として除外（ノイズ排除）

2. **エージェント別シミュレーション（Backtesting）**:

   ```
   過去30日の全推奨について、
   「もし Trend Agent だけで判定していたら？」
   「もし Momentum Agent だけで判定していたら？」
   をシミュレーションし、
   それぞれの勝率と Alpha を計算する。
   ```

   結果イメージ:

   | Agent | Win Rate | Alpha (vs S&P) | 勝率の変化 |
   | :--- | :--- | :--- | :--- |
   | Trend | 62% | +3.2% | +5% (good) |
   | Momentum | 58% | +2.1% | -2% (bad) |
   | Value | 55% | +1.8% | -1% (neutral) |
   | Sentiment | 48% | -0.5% | -8% (worst) |

3. **重み調整（慎重に）**:
   - 上記の結果を使い、重みを微調整する。
   - **重要**: ±1%の微調整に止め、 **±4% の大きな変更は禁止**（過学習防止）。
   - 調整アルゴリズム:

     ```python
     IF agent_alpha > market_alpha:
         new_weight = current_weight + 0.01  # +1% だけ
     ELIF agent_alpha < (market_alpha - 2%):
         new_weight = current_weight - 0.01  # -1% だけ
     ELSE:
         new_weight = current_weight  # 変わらず

     new_weight = CLAMP(new_weight, 0.15, 0.45)  # 最小15%, 最大45%
     SAVE(new_weight)
     ```

   - **さらに重要**: 同一エージェントの重みが10日連続で上下した場合は、「過学習の可能性」として、自動的に初期値にリセット。

4. **Market Regime 別レビュー（Advanced）**:
   - 単純な勝率だけでなく、「正常相場の時の Trend Agent」「危機相場の時の Trend Agent」など、相場環境別に分離してレビュー。
   - 例：「Trend Agent は正常相場では70%勝率だが、危機相場では40%。Momentum Agent は逆に危機相場で65%。→危機モード時の Momentum ウエイト優先度を上げる」

5. **反省文生成（Gemini）**:
   - 今日の大きな失敗事例（複数ある場合は最大3つ）をGeminiに投げ、「なぜこの銘柄が暴落したのか、システムは何を見落としたのか」をAIに分析させる。（モデル: 原則 **gemini-3-pro**）
   - 制約：**「根拠のない推測は書くな、必ず事実（ニュース、チャート形状）を引用しろ」** というプロンプト指示。
   - **Finnhub Newsの永続化**:
     - ニュースURLだけでは、記事削除やリンク切れの問題が発生します。
     - **必ず以下をDBに保存**: ニュースタイトル、発信元（Bloomberg, Reuters等）、発表日時
     - これにより、リンク切れしても「何の記事だったか」が後で確認可能です。
   - 結果を「Today's Lesson」としてダッシュボードに表示。

6. **ログ記録**:
   - 全処理を `performance_log`, `indicators_weights` に記録。
   - 監査・バックテスト用に12ヶ月分を保持。

---

#### 3.1.4 ペーパートレード・シミュレーション（Phase 2）

**背景・目的**:
単なる「買いシグナル」の提供だけでは、システムの有効性を証明できない。ユーザーが自己判断で売買するため、AIの推奨が本当に利益をもたらすかを追跡できない。

**解決策**: 仮想ポートフォリオを自動運用し、完全なトレードサイクル（エントリー→保有→エグジット）をシミュレーション。

##### 3.1.4.1 仮想ポートフォリオ管理

**ポジション管理**:
- 推奨銘柄が生成された時点で、仮想的に「買い」を実行
- 初期資金: ¥100,000（仮想）
- ポジションサイズ: 均等配分（例: 5銘柄なら各20%）
- 最大同時保有: 10銘柄

**データベーススキーマ**:

```sql
-- 仮想ポートフォリオ
CREATE TABLE virtual_portfolio (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  strategy_mode VARCHAR(20) NOT NULL,  -- 'conservative' | 'aggressive'
  symbol VARCHAR(10) NOT NULL,
  entry_date DATE NOT NULL,
  entry_price DECIMAL(12, 4) NOT NULL,
  shares DECIMAL(12, 4) NOT NULL,
  position_value DECIMAL(14, 2) NOT NULL,
  status VARCHAR(20) DEFAULT 'open',  -- 'open' | 'closed'
  exit_date DATE,
  exit_price DECIMAL(12, 4),
  exit_reason VARCHAR(50),  -- 'ai_signal' | 'stop_loss' | 'take_profit' | 'max_hold'
  realized_pnl DECIMAL(14, 2),
  realized_pnl_pct DECIMAL(8, 4),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(strategy_mode, symbol, entry_date)
);

-- ポートフォリオ日次スナップショット
CREATE TABLE portfolio_daily_snapshot (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  snapshot_date DATE NOT NULL,
  strategy_mode VARCHAR(20) NOT NULL,
  total_value DECIMAL(14, 2) NOT NULL,
  cash_balance DECIMAL(14, 2) NOT NULL,
  positions_value DECIMAL(14, 2) NOT NULL,
  daily_pnl DECIMAL(14, 2),
  daily_pnl_pct DECIMAL(8, 4),
  cumulative_pnl DECIMAL(14, 2),
  cumulative_pnl_pct DECIMAL(8, 4),
  sp500_cumulative_pct DECIMAL(8, 4),  -- ベンチマーク比較用
  alpha DECIMAL(8, 4),  -- cumulative_pnl_pct - sp500_cumulative_pct
  open_positions INTEGER,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(snapshot_date, strategy_mode)
);

-- トレード履歴（クローズしたポジション）
CREATE TABLE trade_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  strategy_mode VARCHAR(20) NOT NULL,
  symbol VARCHAR(10) NOT NULL,
  entry_date DATE NOT NULL,
  entry_price DECIMAL(12, 4) NOT NULL,
  exit_date DATE NOT NULL,
  exit_price DECIMAL(12, 4) NOT NULL,
  hold_days INTEGER NOT NULL,
  pnl DECIMAL(14, 2) NOT NULL,
  pnl_pct DECIMAL(8, 4) NOT NULL,
  exit_reason VARCHAR(50) NOT NULL,
  entry_score INTEGER,  -- 推奨時のスコア
  market_regime_at_entry VARCHAR(20),
  market_regime_at_exit VARCHAR(20),
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

##### 3.1.4.2 AIベース売りシグナル生成

**売りシグナル判定ロジック**（毎日の夕方バッチで実行）:

1. **AIスコア再評価**:
   - 保有中の銘柄を毎日再スコアリング
   - スコアが閾値以下に低下した場合 → 売りシグナル
   - 例: V1で60点以下、V2で75点以下に低下

2. **リスク管理ルール**（ハードストップ）:
   - **損切り**: -7%で強制エグジット
   - **利確**: +15%で強制エグジット
   - **最大保有期間**: 10営業日で強制エグジット

3. **Market Regime 変化**:
   - 保有中に「危機モード」に遷移 → 全ポジションエグジット検討

**売りシグナル優先度**:
```
1. ハードストップ（損切り/利確） → 即時エグジット
2. Market Regime 危機 → 即時エグジット
3. AIスコア低下 → 翌営業日の寄付でエグジット
4. 最大保有期間到達 → 翌営業日の寄付でエグジット
```

##### 3.1.4.3 パフォーマンス計測

**KPI**:
- **累積リターン**: ポートフォリオ全体の累積収益率
- **Alpha**: S&P 500との差分（超過リターン）
- **シャープレシオ**: リスク調整後リターン
- **最大ドローダウン**: 最高値からの最大下落率
- **勝率**: 利益トレード / 全トレード
- **平均保有期間**: トレードの平均日数
- **リスクリワード比**: 平均利益 / 平均損失

**ダッシュボード表示**:
- エクイティカーブ（ポートフォリオ価値の推移）
- S&P 500との比較チャート
- 現在のオープンポジション一覧
- 最近のクローズトレード一覧
- 戦略別（V1 vs V2）のパフォーマンス比較

##### 3.1.4.4 バッチ処理フロー

**朝バッチ（買いシグナル処理）**:
```
1. 新規推奨銘柄を取得
2. 仮想ポートフォリオに追加（当日Open価格でエントリー）
3. ポジションサイズを計算（均等配分）
4. virtual_portfolio に INSERT
```

**夕方バッチ（売りシグナル処理）**:
```
1. オープンポジションを取得
2. 各ポジションの現在価格を取得
3. 売りシグナル判定:
   a. 損切り/利確チェック
   b. Market Regime チェック
   c. AIスコア再評価
   d. 最大保有期間チェック
4. エグジット対象をクローズ
5. trade_history に記録
6. portfolio_daily_snapshot を更新
7. ベンチマーク（S&P 500）との比較を計算
```

##### 3.1.4.5 閉ループ・フィードバックシステム（核心機能）

**背景・問題意識**:
従来の設計では「振り返り」が単なるテキスト出力で終わり、次のスコアリングサイクルに反映されない。これでは：
- AIが「閾値が高すぎる」と分析しても、閾値は変わらない
- 見逃した機会を検出しても、次回も同じ閾値で見逃す
- 「動くだけで意味がない」システムになる

**解決策**: Walk-Forward Optimization + Bandit Algorithm の概念を適用し、パフォーマンスに基づいて閾値を自動調整する閉ループシステムを構築。

**データベーススキーマ**:

```sql
-- スコアリング設定（動的閾値管理）
CREATE TABLE scoring_config (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  strategy_mode VARCHAR(20) NOT NULL UNIQUE,  -- 'conservative' | 'aggressive'
  threshold DECIMAL(5, 2) NOT NULL,  -- 現在の閾値（初期: conservative=60, aggressive=75）
  min_threshold DECIMAL(5, 2) NOT NULL DEFAULT 40,  -- 下限
  max_threshold DECIMAL(5, 2) NOT NULL DEFAULT 90,  -- 上限
  last_adjustment_date DATE,
  last_adjustment_reason TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 閾値変更履歴（Walk-Forward検証用）
CREATE TABLE threshold_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  strategy_mode VARCHAR(20) NOT NULL,
  old_threshold DECIMAL(5, 2) NOT NULL,
  new_threshold DECIMAL(5, 2) NOT NULL,
  adjustment_date DATE NOT NULL,
  reason TEXT NOT NULL,
  -- 変更を決定した根拠データ
  missed_opportunities_count INTEGER,
  missed_avg_return DECIMAL(8, 4),
  picked_avg_return DECIMAL(8, 4),
  not_picked_avg_return DECIMAL(8, 4),
  -- Walk-Forward Efficiency
  wfe_score DECIMAL(5, 2),  -- 期待効率（>50%で有効）
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 初期データ
INSERT INTO scoring_config (strategy_mode, threshold, min_threshold, max_threshold) VALUES
  ('conservative', 60, 40, 80),
  ('aggressive', 75, 50, 90);
```

**閾値調整ロジック**（夕方バッチで実行）:

```python
def calculate_optimal_threshold(
    current_threshold: float,
    missed_opportunities: list,
    picked_performance: list,
    strategy_mode: str,
) -> tuple[float, str]:
    """
    Walk-Forward + UCB風の閾値最適化

    Returns:
        (new_threshold, reason)
    """
    # 1. 見逃し分析
    if missed_opportunities:
        missed_scores = [m['score'] for m in missed_opportunities]
        missed_avg_score = sum(missed_scores) / len(missed_scores)
        missed_avg_return = sum(m['return_pct'] for m in missed_opportunities) / len(missed_opportunities)
    else:
        missed_avg_score = None
        missed_avg_return = 0

    # 2. 推奨銘柄の実績
    if picked_performance:
        picked_avg_return = sum(p['return_pct'] for p in picked_performance) / len(picked_performance)
    else:
        picked_avg_return = 0

    # 3. 調整判定
    adjustment = 0
    reason_parts = []

    # ケース1: 見逃しが多く、かつ見逃した銘柄のスコアが閾値に近い
    if len(missed_opportunities) >= 3 and missed_avg_score:
        gap = current_threshold - missed_avg_score
        if gap <= 10:  # 閾値から10点以内で見逃し
            adjustment = -3  # 閾値を3点下げる
            reason_parts.append(f"見逃し{len(missed_opportunities)}件（平均スコア{missed_avg_score:.0f}、閾値との差{gap:.0f}）")

    # ケース2: 推奨銘柄のパフォーマンスが悪い
    if len(picked_performance) >= 5 and picked_avg_return < -1:
        adjustment = +2  # 閾値を2点上げる（より厳選）
        reason_parts.append(f"推奨銘柄平均リターン{picked_avg_return:.1f}%（低調）")

    # ケース3: 推奨銘柄が好調で、見逃しも少ない
    if len(picked_performance) >= 5 and picked_avg_return >= 3 and len(missed_opportunities) <= 1:
        # 現状維持（うまくいっている）
        reason_parts.append(f"好調維持（推奨平均{picked_avg_return:.1f}%）")

    # 4. 変更幅制限（急激な変更を防ぐ）
    adjustment = max(-5, min(5, adjustment))

    new_threshold = current_threshold + adjustment

    # 5. 範囲制限
    limits = {'conservative': (40, 80), 'aggressive': (50, 90)}
    min_t, max_t = limits.get(strategy_mode, (40, 90))
    new_threshold = max(min_t, min(max_t, new_threshold))

    reason = "; ".join(reason_parts) if reason_parts else "変更なし"

    return new_threshold, reason
```

**フィードバックループのフロー**:

```
┌─────────────────────────────────────────────────────────────┐
│                    CLOSED FEEDBACK LOOP                      │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  [Morning Batch]                                             │
│  1. scoring_config から現在の閾値を読み込む                  │
│  2. 閾値に基づいて銘柄をスコアリング・選別                   │
│  3. daily_picks に保存                                       │
│                                                              │
│  [5日後 Evening Batch]                                       │
│  4. 全銘柄のリターンを計算                                   │
│  5. 見逃した機会を特定（was_picked=False, return>=3%）       │
│  6. calculate_optimal_threshold() で最適閾値を計算           │
│  7. scoring_config を UPDATE                                 │
│  8. threshold_history に変更を記録                           │
│  9. AI reflection を生成（変更内容を含む）                   │
│                                                              │
│  [次の Morning Batch]                                        │
│  → 更新された閾値で銘柄選別                                  │
│  → ループ継続                                                │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**Walk-Forward Efficiency (WFE) による検証**:

閾値変更の有効性を検証するため、WFEを計算：

```
WFE = (変更後の期待リターン) / (変更前の期待リターン)

WFE > 0.5 → 変更を採用
WFE <= 0.5 → 変更を却下し、前の閾値に戻す
```

**安全装置**:
- 閾値変更は1日あたり最大±5点まで
- 最小/最大閾値の範囲制限
- 連続して同方向に変更しすぎた場合は一時停止
- 変更履歴を保持し、いつでもロールバック可能

---

### 3.2 ユーザー機能

#### 3.2.1 認証・プロフィール

- メール + パスワード登録（Supabase Auth）
- 簡易プロフィール:
  - タイムゾーン（自動検出またはマニュアル設定）
  - リスク許容度（conservative / balanced / aggressive）
    - **今後の拡張**: リスク許容度により、推奨銘柄の性質を自動フィルタ（例：conservative では PBR > 2 は除外）

#### 3.2.2 通知設定

- 朝のブリーフィング通知: 「今日のAI厳選銘柄」（ON/OFF）
- 時間指定: ユーザーのタイムゾーンで指定時刻に送信
- **推奨なしの日の通知**: 「今日は推奨銘柄なし」という通知も送信する（信頼性強化）

#### 3.2.3 フィードバック・相互作用

- 「興味あり」「見送り」ボタンをクリック → 動作ログとして記録
- 将来的には、ユーザー個人の選好学習に活用（Phase 3以降）

#### 3.2.4 API透明性

- どのデータを使って推奨しているか、ユーザーに明示
- 最新の重み値、Market Regime 判定結果を見るダッシュボード
- (管理者向け) Gemini プロンプトのテンプレートを確認可能

---

## 4. データベース設計（Supabase Postgres）

### 4.1 テーブル一覧

#### `users`

```sql
id (uuid, PK)
email (string, unique)
created_at (timestamp)
timezone (string, default: 'UTC')
risk_tolerance (enum: 'conservative' | 'balanced' | 'aggressive')
notification_enabled (boolean, default: true)
notification_time (time, default: '07:00')
```

#### `market_regime_history`

```sql
id (uuid, PK)
check_date (date)
vix_level (decimal)
market_regime (enum: 'normal' | 'adjustment' | 'crisis')
sp500_sma20_deviation_pct (decimal, -5.2 など)
nyse_advance_decline_ratio (decimal, 0.8 など)  -- Phase 2で再活用（Phase 1はnull許容）
volatility_cluster_flag (boolean)
notes (text, 判定ロジックの詳細)
created_at (timestamp)
```

#### `daily_picks`

```sql
id (uuid, PK)
batch_date (date, unique)
symbols (json array: ["TSLA", "AAPL", ...])
pick_count (integer, 0-5)
market_regime (enum, 参照)
created_at (timestamp)
status (enum: 'generated' | 'published')
```

#### `stock_scores`

```sql
id (uuid, PK)
batch_date (date)
symbol (string)

trend_score (integer 0-100)
momentum_score (integer 0-100)
value_score (integer 0-100)
sentiment_score (integer 0-100)

composite_score (integer 0-100)
percentile_rank (integer, 当日の候補内での相対順位 1-100)

reasoning (text, Gemini生成、引用元付き)
price_at_time (decimal, 当日Open価格)

earnings_date (date or null, 決算予定日があれば記載)

-- CR-08: Earnings timezone/時刻帯/UTCタイムスタンプ（監査・判定用）
earnings_timezone (string, 例: "America/New_York")
earnings_time_of_day (enum: 'bmo' | 'amc' | 'dmh' | 'unknown')
earnings_timestamp_utc (timestamp, 決算イベント時刻が特定できる場合のみ保存。不可ならnull)

market_regime_at_time (enum)

-- CR-04: Lookahead Bias監査証跡
cutoff_timestamp (timestamp, 推奨計算の情報締切UTC)
input_data_asof (jsonb, {prices_asof, news_asof, fundamentals_asof, earnings_asof} のUTCを保存)

created_at (timestamp)
UNIQUE(batch_date, symbol)
```

#### `indicators_weights`

```sql
id (uuid, PK)
updated_date (date)
trend_weight (decimal, default: 0.35, range: 0.20-0.45)
momentum_weight (decimal, default: 0.35, range: 0.20-0.45)
value_weight (decimal, default: 0.20, range: 0.10-0.30)
sentiment_weight (decimal, default: 0.10, range: 0.05-0.20)
version (integer, incrementing)
change_reason (text, 「Trend Agent 勝率70%のため +1%」など)
previous_weights (json, 参考用)
created_at (timestamp)
```

#### `performance_log`（パフォーマンス追跡）

```sql
id (uuid, PK)
pick_date (date, 推奨した日)
symbol (string)
recommendation_open_price (decimal, 推奨日の当日Open価格 ★重要)
recommendation_score (integer 0-100)
recommendation_percentile (integer, 当日内の相対順位)
market_regime_at_time (enum)
earnings_date (date or null, 決算予定日)
cutoff_timestamp (timestamp, 推奨計算の情報締切UTC)

-- 複数期間での成績
check_date_1d (date, 翌営業日)
price_1d (decimal)
return_pct_1d (decimal, null if <1%)
status_1d (enum: 'win' | 'loss' | 'flat' | 'pending')

check_date_5d (date, 5営業日後)
price_5d (decimal)
return_pct_5d (decimal, null if <1%)
status_5d (enum: 'win' | 'loss' | 'flat' | 'pending')

-- 分析用
which_agent_was_right (text, 「Momentum Agent スコア86だったから当たった」など)
which_agent_was_wrong (text)
notes (text)
created_at (timestamp)
```

#### `agent_performance_daily`（エージェント別追跡）

```sql
id (uuid, PK)
analysis_date (date)
agent_name (enum: 'trend' | 'momentum' | 'value' | 'sentiment')
win_rate_30d (decimal, 0.68 など)
alpha_vs_sp500_30d (decimal, +3.2 など)
recommendation_count_30d (integer)
avg_return_when_correct (decimal, +5.2)
avg_loss_when_wrong (decimal, -2.3)
notes (text)
created_at (timestamp)
```

#### `user_interactions`

```sql
id (uuid, PK)
user_id (uuid, FK to users)
stock_id (uuid, FK to stock_scores)
action (enum: 'viewed' | 'liked' | 'disliked')
created_at (timestamp)
```

#### `ai_lessons`

```sql
id (uuid, PK)
lesson_date (date)
lesson_text (text, Gemini生成、引用元付き)
biggest_miss_symbols (json array, 複数ある場合)
miss_analysis (text)
weight_changes (json, 「Trend +1%, Sentiment -1%」など)
created_at (timestamp)
```

#### `news_archive`（ニュースの永続化）

```sql
id (uuid, PK)
finnhub_news_id (string, unique, Finnhub から提供されるID)
symbol (string)
news_title (text, ニュースタイトル)
news_url (text, オリジナルURL、ただしリンク切れ対策として以下と併記)
source (string, 「Bloomberg」「Reuters」など発信元)
published_date (timestamp, ニュース公開日)
article_summary (text, ニュース要約)
sentiment_score (decimal, Finnhub から取得)
created_at (timestamp)
archived_date (date, 提言日)
```

---

## 5. バックエンド処理フロー

### 5.1 毎日の定期処理

#### Task 1: 夕方クローズ後（16:00 ET / 翌朝6:00 JST）

**実行者**: GitHub Actions Scheduled Workflow（Python スクリプト）

**実行内容**: 前日〜過去の推奨結果を評価し、重みを更新

1. **データ収集**:
   - Supabase から、3日前・7日前・14日前の daily_picks を取得
   - 各銘柄の現在価格を Finnhub から取得
   - performance_log の当該行を更新（リターン確定）

2. **勝敗判定**:
   - 5営業日経過した銘柄について、リターン（%）を計算
   - **★重要**: 計測基準価格は「推奨日の当日Open価格」（DB: `recommendation_open_price`）を使用
   - ±1% 以上なら勝敗判定、±1% 未満は「フラット」で除外

3. **エージェント別シミュレーション**:
   - 過去30日の全推奨に対し、単一エージェント判定での勝率を逆算計算
   - Alpha（vs S&P 500）を計算
   - 結果を agent_performance_daily に INSERT

4. **重み再計算**:
   - 上記の Alpha 結果を基に、±1% の微調整
   - 10日連続で同方向調整は「リセット」
   - indicators_weights テーブルに新しい行を INSERT

5. **Market Regime の事後評価**:
   - 「実際にこの相場環境判定は正しかったか？」を振り返る
   - Market Regime フィルターの精度を metrics として記録

6. **反省文生成**:
   - Gemini: 「今日最も外れた銘柄はなぜか？システムは何を見落としたか？」（モデル: 原則 **gemini-3-pro**）
   - **制約**: 「推測するな、ニュース・チャート・指標の具体数値を引用しろ」
   - **レート制限対策**: Gemini API呼び出し間に `time.sleep(2)` を挿入するか、exponential backoff リトライを実装
   - ai_lessons に保存

7. **通知トリガー**:
   - ユーザーに「成績確認メール」を送信（オプション）

**実装**: Python + Supabase Python SDK

#### Task 2: 朝マーケット前（07:00 JST / 16:00 ET 前日）

**実行者**: GitHub Actions Scheduled Workflow（Python スクリプト）

**実行内容**: 新しいスコアを計算し、「Today's Picks」を生成

1. **市場データ取得**:
   - Finnhub から全銘柄の価格、財務、ニュース、センチメント取得
   - **★重要**: Finnhub Earnings Calendar API を呼び出し、今後3営業日のEarnings Callスケジュール取得
   - テクニカル指標計算（SMA, RSI, MACD）
   - Supabase に保存

2. **Market Regime 判定**:
   - VIX, S&P 500 乖離, ボラティリティ を計算（Phase 1では Advance/Decline Ratio は使用しない）
   - market_regime_history に記録
   - 該当する相場環境フラグを立てる

3. **粗選別**:
   - 流動性フィルター（時価総額 > ¥300B, 出来高 > 100万株）
   - **決算フィルター**: Earnings Calendar データから、今後3営業日以内に決算予定がある銘柄を**強制除外**
   - ニュース数・センチメント基準でランク
   - 候補を 50-100 銘柄に絞る
   - 一覧を JSON で Gemini プロンプトに埋め込み

4. **Gemini スコアリング**:
   - 各候補について、複数バッチに分けて（例：10銘柄ごと）Gemini を呼び出し（モデル: 原則 **gemini-3-flash**）
   - **レート制限対策**: API呼び出し間に `time.sleep(1-2)` を挿入、または exponential backoff (初回1秒→2秒→4秒...) を実装
   - 各エージェントのスコア（0-100）と簡潔な理由を返させる
   - レスポンス: JSON形式で

     ```json
     {
       "symbol": "TSLA",
       "trend_score": 85,
       "momentum_score": 78,
       "value_score": 35,
       "sentiment_score": 72,
       "reasoning": "トレンド: 50日線上 ✓, モメンタム: RSI 68, 割安度: PER 72 (業界平均 28) ✗"
     }
     ```

5. **総合スコア計算**:
   - Market Regime に基づいて、その日の重みを確定
   - composite_score = trend_score * trend_weight + ...
   - **当日の Open 価格を記録**（price_at_time, recommendation_open_price）
   - stock_scores テーブルに INSERT

6. **相対化・ランキング**:
   - 全スコアを偏差値化（percentile_rank）
   - 上位から順にランキング

7. **推奨数決定と daily_picks 生成**:
   - Market Regime に応じた max_picks を決定（0-5）
   - 上位 N件を daily_picks にINSERT
   - status = 'published' に変更

8. **通知トリガー**:
   - ユーザー向けメール通知（Supabase メール）
   - プッシュ通知（OneSignal連携、Phase 3）

**実装**: Python + Supabase SDK + Gemini API

### 5.2 データソース

| データ | ソース | 更新頻度 | コスト |
| :--- | :--- | :--- | :--- |
| 株価（OHLCV） | Finnhub Free | 15分遅延 | 無料（目安: 60 calls/min。超過時は429想定） |
| テクニカル指標 | 自社計算（Python: TA-Lib） | 毎日1回 | 無料 |
| 企業財務（PER, PBR等） | Finnhub Free | 日1回更新 | 無料 |
| ニュース＆センチメント | Finnhub News Sentiment API | リアルタイム | 無料（月制限あり） |
| **Earnings Calendar** | **Finnhub Earnings API** | **日1回更新** | **無料** |
| VIX / S&P 500 | Finnhub | リアルタイム | 無料 |
| AI分析・スコア計算 | Gemini API | オンデマンド | **月$300-500 見積（レート制限考慮）** |

> **Note**: Finnhub 無料枠の制限が厳しい場合、Alpha Vantage または IEX Cloud 等への移行も検討。

---

## 6. フロントエンド仕様（Next.js）

### 6.1 ページ構成

#### Route: `/` (トップページ)

**Today's Picks** (主要コンテンツ)

- Market Regime ステータス表示（「通常」「調整局面」「危機」）
- 推奨銘柄数の表示（例：「本日 3銘柄」「本日は推奨なし」）
- カード型レイアウト（モバイル対応）
- 上位推奨銘柄を表示（0-5件）
- 各カードに「引用元リンク」を含める
- **寄付価格に関する注記**: 「表示価格は前日終値。寄付時に変動します」
- クリックで詳細モーダルを開く

#### Route: `/stock/[symbol]` (銘柄詳細)

- TradingView チャート
- スコア内訳表示（重み、相対順位）
- Market Regime 表示（推奨時の環境）
- Geminiの詳細分析コメント（引用元付き）
- 過去の推奨履歴（同銘柄を過去推奨したか）
- **決算警告**: 「⚠️ この銘柄は今後3営業日以内に決算発表があります」
- 「見送り」「興味あり」ボタン

#### Route: `/performance` (パフォーマンスダッシュボード)

- **KPI表示**:
  - 超過リターン（Alpha vs S&P 500, 30日）
  - S&P 500 との累積リターン比較グラフ
  - シャープレシオ または 最大ドローダウン
- **エージェント別勝率** (グラフ):
  - 過去30日間の、各エージェント（Trend, Momentum, Value, Sentiment）の勝率
  - 相場環境別の勝率（正常 vs 調整 vs 危機）
- **Today's Lesson** セクション:
  - 最新の学習内容
  - 重み調整の内訳（「Trend +1%, Sentiment -1%」）

#### Route: `/dashboard` (設定・プロフィール)

- 通知設定（ON/OFF、時間指定）
- タイムゾーン選択
- リスク許容度設定（今後の拡張で有効化）
- API 透明性（最新の重み、Market Regime 表示、Prompt テンプレート表示）

#### Route: `/auth` (ログイン・サインアップ)

- Supabase Auth UI（メール＋パスワード）

### 6.2 コンポーネント設計

**主要コンポーネント**:

- `<MarketRegimeStatus />`: 現在の相場環境バッジ
- `<StockCard />`: 銘柄カード（今日のピック用）
- `<ScoreBreakdown />`: スコア内訳表示（重み付き）
- `<PerformanceChart />`: 成績推移チャート（Alpha表示）
- `<TradingViewChart />`: 軽量チャートウィジェット
- `<LessonBox />`: 今日の学習内容テキスト（引用元リンク付き）
- `<AgentPerformance />`: エージェント別勝率チャート
- `<EarningsWarning />`: 決算警告バナー

### 6.3 実装上の注意点

- **API呼び出し**: フロント→Supabase Edge Function（軽い処理のみ）→Gemini（禁止）
  - 重い処理は GitHub Actions で事前実行し、結果を Supabase に保存
- **キャッシング**: `daily_picks` は毎日固定、キャッシュ有効期限 24 時間
- **Realtime**: Supabase Realtime で `daily_picks` 変更を監視（今後の拡張）

---

## 7. セキュリティ・運用

### 7.1 API キー管理

- Gemini API キー: GitHub Actions Secrets（ワークフロー実行時に参照）
- Finnhub API キー: 同じく GitHub Actions Secrets
- Supabase API キー: Vercel 環境変数 + GitHub Actions Secrets（分離管理）
- ユーザー認証: Supabase JWT

### 7.2 データプライバシー

- ユーザーの相互作用（「いいね」など）のみ保存、取引自体は記録しない
- GDPR対応を念頭（ユーザーデータ削除API）
- パフォーマンスログは完全に匿名化してパブリックダッシュボード化も可能

### 7.3 監視・ログ

- GitHub Actions のワークフロー実行ログ（失敗時は Slack 通知）
- Supabase メトリクス（DB接続数、API呼び出し）
- Vercel Analytics（フロント応答時間）
- 定期的に推奨精度を集計し、Market Regime フィルターが適切に動作しているか検査

### 7.4 ドキュメント

- Gemini プロンプトのテンプレート（管理者向けで確認可能）
- バッチ処理の詳細ログ（重み調整の根拠など）

---

## 8. MVP スコープ（第1リリース）

**対象機能** (Phase 1: 3-4週間):

1. ✅ Market Regime 判定ロジック（足切り機能）
2. ✅ **決算フィルター** (今後3営業日のEarnings除外)
3. ✅ AIスクリーニング・スコア計算（4指標、固定重み）
4. ✅ 毎日の自動ピック生成（0-5銘柄）
5. ✅ ダッシュボード表示（カード型、相場環境表示）
6. ✅ 銘柄詳細ビュー（チャート＋スコア内訳＋引用元表示）
7. ✅ **当日Open価格の記録と勝敗計測**
8. ✅ パフォーマンスログ記録（勝敗判定、複数期間）
9. ✅ ユーザー認証（メール＋パスワード）
10. ✅ メール通知（毎日のピック配信）
11. ✅ GitHub Actions でのバッチ処理（レート制限対策含む）

**対象外（Phase 2以降）**:

- 🔶 **ペーパートレード・シミュレーション**（仮想ポートフォリオ、AIベース売りシグナル、パフォーマンス計測）
- 🔶 重み自動調整（フェーズ2: 相場環境別調整から開始）
- 🔶 プッシュ通知（OneSignal統合）
- 🔶 ユーザーフィードバック学習（相互作用データ活用）
- 🔶 リスク許容度別フィルタリング

---

## 9. 開発スケジュール

| Phase | 内容 | 期間 | 完成物 |
| :--- | :--- | :--- | :--- |
| **Phase 1** | インフラ整備 + MVP開発（Market Regime + 決算フィルター含む） | 3-4週間 | Vercel上で動作するダッシュボード＋毎日のピック配信＋GitHub Actionsパイプライン＋レート制限対策 |
| **Phase 2** | **ペーパートレード・シミュレーション** + **閉ループ・フィードバックシステム** + エージェント別パフォーマンス分析 | 2-3週間 | 仮想ポートフォリオ＋AIベース売りシグナル＋**閾値自動調整**＋パフォーマンスダッシュボード |
| **Phase 3** | UI/UX改善＋プッシュ通知 + ユーザー学習機能 | 2週間 | 本格運用開始 |

---

## 10. 成功指標（KPI）

| KPI | 目標 | 計測方法 | 備考 |
| :--- | :--- | :--- | :--- |
| **Alpha (vs S&P 500)** | 30日移動平均で +2% 以上 | performance_log 集計（Open価格ベース） | 勝率ではなく、絶対リターンで評価 |
| **推奨「なし」の判定** | 月に1-2日は「推奨なし」 | daily_picks テーブルの pick_count = 0 の日数 | 相場が悪い日に「出さない勇気」を評価 |
| **Market Regime 精度** | 「危機判定」時の実際の落ち幅 > -3% | 事後検証 | 足切り機能が本当に機能しているか |
| **決算フィルター機能率** | 推奨時点での決算外し率 > 95% | stock_scores テーブルの earnings_date フィールド | 決算ギャンブル排除の確認 |
| **ユーザー保持率** | 初期ユーザーの30日継続率 > 40% | user_interactions 追跡 | |
| **アプリ応答時間** | < 2秒 | Vercel Analytics | フロント表示 |
| **バッチ処理実行時間** | < 10分（朝・夕） | GitHub Actions ログ | スケーラビリティの確認 |
| **Gemini API レート制限エラー率** | < 1% | GitHub Actions ログ, Gemini API メトリクス | レート制限対策の有効性 |
| **API コスト** | 月 $200-300（Gemini） | GCP 請求 | 効率性の監視 |
| **見逃し率の改善** | 月間見逃し機会数が前月比で減少 | threshold_history + stock_scores | 閉ループ・フィードバックの有効性 |
| **閾値調整の安定性** | 調整回数 < 10回/月 | threshold_history | 過度な調整は不安定なシグナル |
| **ペーパートレードAlpha** | 累積で S&P 500 を上回る | portfolio_daily_snapshot | 仮想運用の実効性 |

---

## 11. 重要な限界と責任表示

### 11.1 必ずユーザーに伝えるべき事項

1. **「このAIは100%正確ではない」**
   - 市場は本質的にランダムな側面がある
   - 推奨精度の上限は 60-65% 程度が現実的
2. **「相場環境で精度が大きく変動する」**
   - トレンド相場では80%近い勝率になるが、レンジ相場では50%以下に低下
3. **「推奨銘柄を買ったら必ず損切りルールを決めること」**
   - -5% で損切る、など
4. **「このアプリは推奨であって、投資助言ではない」**
   - ユーザーは自己責任で判断して取引すること
5. **「寄付価格が前日終値と大きく異なる可能性」**
   - Gap Up/Down のリスクを承知の上で取引すること
6. **「決算銘柄は除外されている」**
   - 決算の不確実性を排除するため、推奨対象から除外されていることを明記

### 11.2 法的注記

- アプリの免責事項ページに上記を明記
- ユーザーの利用規約に「推奨に基づいた取引で損失が出ても、開発者は責任を負わない」を記載

---

## 12. 参考・参考リソース

- Finnhub API Docs: https://finnhub.io/docs/api
- Finnhub Earnings Calendar: https://finnhub.io/docs/api/earnings-calendar
- Gemini API Docs: https://ai.google.dev/
- Supabase Docs: https://supabase.com/docs
- GitHub Actions Workflows: https://docs.github.com/en/actions
- Next.js Best Practices: https://nextjs.org/docs
- TradingView Charts: https://www.tradingview.com/lightweight-charts/

---

## Appendix A: Market Regime 判定ロジック（詳細）

### Tier 1: Market Regime フィルター の詳細計算式

```python
def decide_market_regime(
    vix: float,
    sp500_price_today: float,
    sp500_sma20: float,
    volatility_5d_avg: float,
    volatility_30d_avg: float,
    # Phase 2で復活させる（Phase 1はNone固定でもOK）
    nyse_ad_ratio: float | None = None,
) -> str:
    """
    Market Regime を 'normal' | 'adjustment' | 'crisis' で返す。
    Phase 1: VIX / SP500乖離 / Volatility cluster のみで判定し、A/D比は使わない。
    """

    flags = {"crisis": 0, "adjustment": 0}

    # 1) VIX
    if vix > 30:
        flags["crisis"] += 1
    elif 20 < vix <= 30:
        flags["adjustment"] += 1

    # 2) S&P 500 deviation
    deviation_pct = ((sp500_price_today - sp500_sma20) / sp500_sma20) * 100
    if deviation_pct < -3:
        flags["adjustment"] += 1

    # 3) Volatility cluster
    if volatility_5d_avg > (volatility_30d_avg * 1.5):
        flags["adjustment"] += 1

    # 4) Market breadth (Phase 2)
    if nyse_ad_ratio is not None and nyse_ad_ratio < 0.7:
        flags["adjustment"] += 1

    # Final decision
    if flags["crisis"] >= 1:
        return "crisis"
    if flags["adjustment"] >= 2:
        return "adjustment"
    return "normal"
```

---

## Appendix B: API レート制限対策（実装例）

### Gemini API コール時のリトライロジック

```python
import time
from functools import wraps

def rate_limit_aware(max_retries=3, base_sleep=1):
    """Gemini API のレート制限に対応するデコレータ"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if "429" in str(e) or "RESOURCE_EXHAUSTED" in str(e):
                        # Rate Limited
                        sleep_time = base_sleep * (2 ** attempt)  # exponential backoff
                        print(f"Rate limited. Sleeping {sleep_time}s before retry {attempt+1}")
                        time.sleep(sleep_time)
                    else:
                        raise
            raise Exception(f"Failed after {max_retries} retries")
        return wrapper
    return decorator

@rate_limit_aware(max_retries=3, base_sleep=2)
def call_gemini_api(prompt):
    """Gemini API への呼び出し"""
    # 実装
    pass
```

---

## Appendix C: 追加検討事項

### 2024-2025年最新研究・ベストプラクティス

**調査日**: 2025年12月21日
**ステータス**: 要件定義書 v2.1 の補足資料

---

### 1. 過学習検出と Walk-Forward Validation フレームワーク

#### 最新知見

- 従来のバックテストより**50%以上精度が向上**
- **パラメータ数と勝率の相関**が過学習検出の指標となる
- 勝率が高いほど取引数が少ない → 過学習の強い兆候

#### 実装推奨（優先度: HIGH）

```python
def detect_overfitting(optimization_results):
    """パラメータ最適化結果から過学習を検出"""
    df = optimization_results.sort_values('num_trades')
    correlation = df['win_rate'].corr(df['num_trades'])

    # 相関係数が -0.3 以下 → 過学習の可能性
    if correlation < -0.3:
        print("⚠️ WARNING: Overfitting detected!")
        return True
    return False
```

#### ドキュメント統合箇所

- **Section 3.1.3（重み調整ロジック）** に追加
- 月1回の監査で Walk-Forward Validation を実行

---

### 2. Retrieval-Augmented Generation (RAG) + Knowledge Graph

#### 現状問題

- Standard RAG: 幻覚率 30-40%
- 根拠不明な推奨理由が時々生成

#### 最新解決策（優先度: HIGH）

- **Graph-Based RAG**: 幻覚率を6-15%まで削減（金融ドメイン）
- Token使用量も80%削減
- 実装: Neo4j + Pinecone + Gemini

```python
def rag_stock_analysis(symbol, stock_data):
    """RAG パイプライン統合"""
    # Step 1: Knowledge Graph から context 取得
    related_companies = neo4j_query(
        f"MATCH (c:Company {{ticker:'{symbol}'}})-[:SAME_SECTOR]->(s) RETURN s"
    )

    # Step 2: Vector DB から類似ニュース検索
    similar_news = pinecone_search(
        query_vector=embed(stock_data['recent_news']),
        top_k=5
    )

    # Step 3: 検索結果を prompt に統合
    context = format_rag_context(related_companies, similar_news)

    # Step 4: Gemini 呼び出し（RAG prompt）
    prompt = f"""
    === 関連データ（Knowledge Graph 検索） ===
    {context['kg_context']}

    === 類似過去パターン（Vector DB 検索） ===
    {context['vector_context']}

    上記データのみを参照してください。推測・外挿は禁止。
    """

    return call_gemini_api(prompt)
```

#### 参考

- arXiv 2510.24476 - RAG で幻覚40%削減
- Finance Bench ベンチマークで Graph-RAG が SOTA

---

### 3. Market Microstructure 理論との統合

#### 最新知見（2024-2025研究）

- マイクロストラクチャー信号は **高ボラティリティ期（VIX > 25）でのみ有効**
  - 高VIX期: 勝率 60%+
  - 低VIX期: 勝率 50%未満
- 相場環境により Trend/Momentum エージェントの有効性が大きく異なる

#### 実装推奨（優先度: MEDIUM / Phase 2）

```python
def analyze_by_volatility_regime(performance_log_30d):
    """VIX レベルで パフォーマンス分離分析"""
    low_vol_trades = performance_log[performance_log['vix_at_time'] < 15]
    high_vol_trades = performance_log[performance_log['vix_at_time'] > 25]

    print(f"Low VIX Regime (< 15):")
    print(f"  Trend Agent Win Rate: {low_vol_trades['trend_correct'].mean():.1%}")
    print(f"  Momentum Agent Win Rate: {low_vol_trades['momentum_correct'].mean():.1%}")

    # 調整: 低VIX期は Momentum を下げる
    if low_vol_trades['momentum_correct'].mean() < 0.55:
        suggest_weight_adjustment('momentum', -0.02)
```

---

### 4. Ensemble Learning による精度向上

#### 最新成果

- **Blending Ensemble** (LSTM + GRU + FC層): MSE 57.55% 削減
- 方向精度: 33.34% 改善
- 単一モデルより複数アーキテクチャの統合が最有効

#### 実装推奨（優先度: MEDIUM / Phase 2）

```
Phase 1（現状）: composite_score = Gemini_score のみ
Phase 2案: composite_score = 0.6 * Gemini + 0.2 * XGBoost + 0.2 * LSTM
DB 拡張: stock_scores テーブルに ensemble_method フィールド追加
```

#### 参考

- Ensemble Deep Learning for Stock Prediction (NIH 2021)
- 57.55% MSE削減の実績

---

### 5. Conditional Value at Risk (CVaR)

#### VaR の限界

- 最悪ケースの閾値のみ考慮 → リスク過小評価

#### CVaR の利点

- VaR を超えた平均損失も考慮
- ポートフォリオ Sharpe Ratio +15-25%

#### 実装推奨（優先度: MEDIUM / Phase 2）

```python
def calculate_cvar(returns_array, confidence_level=0.95):
    """VaR + CVaR 計算"""
    var = np.percentile(returns_array, (1 - confidence_level) * 100)
    cvar = returns_array[returns_array <= var].mean()
    return var, cvar

# 重み調整に CVaR 制約を追加
# IF Trend_Agent CVaR > -5% THEN weight -= 1%
```

---

### 6. Gap リスク管理と Pre-Market 分析

#### 実装推奨（優先度: HIGH）

- Pre-Market Scanner で Gap を推定
- Gap リスクレベル（HIGH/MEDIUM/LOW）をUI に表示
- 記録: `estimated_gap_pct`, `gap_risk_level` フィールド

#### 既に実装済み ✅

- フロントエンド注記「表示価格は前日終値。寄付時に変動します」
- `stock_scores.price_at_time` (当日Open価格)

---

### 7. Central Bank Communication

#### 最新知見（2024-2025）

- **FOMC ハト派トーン**: +5.2% 株価上昇
- **FOMC タカ派トーン**: -3.5% 株価下落
- ECB プレスカンファレンス sentiment も モメンタムシグナル（相関 0.4-0.6）

#### 実装推奨（優先度: LOW / Phase 3）

- Sentiment Agent 強化案: FOMC声明、ECB通信を自動分析
- Loughran-McDonald 辞書で hawkish/dovish トーン抽出

---

### 8. Reinforcement Learning による完全自動適応化

#### Actor-Critic RL の活用

- 従来の「±1%固定調整」から、RL エージェントが市場環境に応じた動的調整を学習
- State: [VIX, Market_Regime, Agent_Performance_30d]
- Action: [Weight_Adjustment: -2%, -1%, 0%, +1%, +2%]
- Reward: Alpha vs S&P 500

#### 実装推奨（優先度: MEDIUM / Phase 3）

- A2C（Advantage Actor-Critic）または PPO の実装検討
- 参考: FinRL Contests 2023-2025 の TD3 成功例

---

### 9. Lookahead Bias 防止（重要）

#### 実装推奨（優先度: HIGH）

```python
class StrictInformationSet:
    """推奨計算時点での『知り得る情報』をカプセル化"""
    def __init__(self, as_of_date, as_of_time):
        self.cutoff = as_of_date, as_of_time

    def get_historical_prices(self, symbol):
        # cutoff までの価格のみ
        return db.query(f"""
            SELECT * FROM prices
            WHERE symbol = '{symbol}'
            AND timestamp <= '{self.cutoff}'
        """)

    def get_news(self, symbol):
        # 未来のニュースは除外
        return db.query(f"""
            SELECT * FROM news
            WHERE symbol = '{symbol}'
            AND published_date < '{self.cutoff}'
        """)
```

#### ドキュメント統合箇所

- **Section 5.1（バッチ処理）** に Information Set Cutoff を明記
- GitHub Actions ワークフローに cutoff タイムスタンプをログ出力

---

### 10. 外部データソース統合（オプション / Phase 3以降）

**検討対象**（cost-benefit は要評価）:

- Options Flow: ヘッジ需要 vs 投機需要
- Insider Transactions: SEC EDGAR 連携
- ETF Flow: 機関投資家の方向性
- Social Media Sentiment: Reddit, X

**DB スキーマ予約**: `alternative_data` テーブルをあらかじめ設計

---

### 追加 KPI 項目

| KPI | 目標 | 計測方法 |
|-----|------|--------|
| **Walk-Forward過学習スコア** | < 0.3 | 勝率と取引数の相関係数 |
| **Lookahead Bias エラー率** | 0% | Information Set チェック |
| **RAG 幻覚率** | < 15% | 月5件の手動監査 |
| **CVaR (95%)** | < -2% | 統計計算 |
| **Market Regime 別Agent勝率差** | > 15% | VIX帯別分離分析 |

---

### 実装優先度マトリックス

| 優先度 | 項目 | 時期 | 期待効果 |
|--------|------|------|--------|
| **🔴 HIGH** | RAG + Knowledge Graph | Phase 1修正 | 幻覚 30%削減 |
| **🔴 HIGH** | Lookahead Bias 防止 | Phase 1 | 信頼性+40% |
| **🔴 HIGH** | Gap リスク管理 | Phase 1 MVP | 精度+5-10% |
| **🟡 MEDIUM** | Walk-Forward Validation | Phase 1.5 | 過学習検出95% |
| **🟡 MEDIUM** | Microstructure 分離分析 | Phase 2 | 適応性+20% |
| **🟡 MEDIUM** | Ensemble Learning | Phase 2 | 精度+40% |
| **🟡 MEDIUM** | CVaR 管理 | Phase 2 | リターン+15% |
| **🟢 LOW** | Actor-Critic RL | Phase 3 | 完全自動化 |
| **🟢 LOW** | 中央銀行通信分析 | Phase 3 | Sentiment強化 |

---

### 開発チェックリスト（実装前確認事項）

- [ ] Neo4j セットアップ手順を確認
- [ ] Pinecone Embedding モデル（例：text-embedding-3-small）を決定
- [ ] Walk-Forward rolling window サイズを決定（例：60日in / 10日out）
- [ ] CVaR 信頼度レベルを決定（99% / 95% / 90%）
- [ ] Pre-Market データソース（Finnhub vs IB API）を決定
- [ ] GitHub Actions に Information Set Cutoff ログを追加

---

### 参考文献（2024-2025年最新）

#### アカデミック

1. Interpretable Hypothesis-Driven Trading (arxiv 2512.12924) - Walk-Forward + 厳格管理
2. Reinforcement Learning for Trade Execution (arxiv 2507.06345) - マイクロストラクチャー
3. Ensemble Deep Learning for Stock Prediction (NIH 2021) - 57%MSE削減
4. Mitigating Hallucination in LLMs with RAG (arXiv 2510.24476) - 40%削減
5. FinRL Contests 2023-2025 (arxiv 2504.02281) - TD3成功例

#### 業界ガイド

- IBKR Quant: Reinforcement Learning in Trading (2025)
- Interactive Brokers: Future of Backtesting (2025)
- Surmount AI: Walk-Forward vs Backtesting (2025)

---

**作成者**: AI Pick Daily 開発チーム
**最終更新**: 2025年12月21日 (v2.2 統合版)
**ステータス**: 実装開始可能な確定版
